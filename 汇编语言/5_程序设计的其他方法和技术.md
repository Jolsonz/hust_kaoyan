[toc]

一、本章的学习内容：
本章学习汇编语言的高级程序设计技术：
（1）串操作指令的使用格式及功能；
（2）宏指令的定义与调用方式；
（3）模块程序设计方法及连接技术。
    通过本章的学习，能提高编程的效率和质量，简化程序设计的工作，这是汇编语言中最具特色的部分。

二、本章的学习重点：
（1）串操作指令MOVS、CMPS、SCAS的使用格式及功能；
（2）简单宏指令的定义与调用方式；
（3）模块程序设计的方法。

三、本章学习的难点：
 （1）MOVS与MOV、CMPS与CMP功能上的差别及串操作指令的正确使用方法；
 （2）宏指令的定义与调用方式；
 （3）模块之间的组合、定位及通信方式；
 （4）模块化程序设计技术。

# 5.1 字符串操作指令

字符串操作在汇编语言中占有相当的部分

字符串操作在格式和使用方法上互相有许多相似的地方，他们**隐含的使用相同的寄存器，标志位和符号**，如下：

|         功能         |                      说明/使用的寄存器                      |
| :------------------: | :---------------------------------------------------------: |
|      源串指示器      |                        DS  :  SI/ESI                        |
|     目的串指示器     |                        ES :  DI/EDI                         |
|    重复次数计数器    |                           CX/ECX                            |
|  SCAS指令的搜索值在  |                          AL/AX/EAX                          |
| LODS指令的目的地址为 |                          AL/AX/EAX                          |
|  STOS指令的源地址为  |                          AL/AX/EAX                          |
|       传送方向       | DF=0；SI/ESI,DI/EDI自动增量<br/>DF=1; SI/ESI,DI/EDI自动减量 |
|         _SB          |               不带操作数的**字节串**操作指令                |
|         _SW          |                不带操作数的**字串**操作指令                 |
|         _SD          |               不带操作数的**双字串**操作指令                |



## （0）重复前缀[^1]

这些指令前面可加重复前缀，在条件满足的情况下能重复执行，而不用考虑指针在如何移动，循环次数如何控制等问题。

==注意重复前缀每次循环会让CX/ECX减一==

1. REP—重复，无条件重复CX,ECX寄存器中指定的次数

2. REPE/REPZ—相等或为0时重复，即在**（CX/ECX）≠ 0**  且 **ZF=1**时重复，否则重复终止

   > 重复次数还未为0且比较时相等时重复。

3. REPNE/REPNZ—不相等或不为0时重复，即在**（CX/ECX）≠ 0**  且 **ZF=0**时重复，否则重复终止

   > 重复次数不为0且比较不相等时重复

## （1）串传送指令      MOVS

格式:MOVS OPD，OPS   

> MOVSW 字串传送
> MOVSB  字节串传送
> MOVSD  双字串传送

功能:

1. (DS:[SI]/[ESI]) → ES:[DI]/[EDI]
2. 修改串指针，**使之指向下一元素**。修改方式为：
   1. 当DF＝0时，(SI)/(ESI)和（DI/EDI）增量1(字节操作)或2(字操作) 或 4 (双字操作)
   2. 当DF＝1时，(SI)/(ESI)和（DI/EDI）减量1(字节操作)或2(字操作) 或 4 (双字操作)

说明:

1. 该指令可带的重复前缀为：**REP** [^2]

   即当(CX/ECX)≠0时连续传送，直至(CX/ECX)=0。

2. 源串应在**当前数据段**，指针为SI/ESI；目的串应在
   当前**附加数据段**指针为DI/EDI。

例1：将以STR1为首址的字节存储区中存放的字符串传送到以STR2为首址的字节存储区中。

```ASM
 .386
 DATA  SEGMENT  USE16
 STR1  DB   'ABCDEFGHIJKLM ……'   ；输出缓冲区BUF1
 COUNT EQU   $-BUF1              ；BUF1中的字符个数
 STR2  DB    COUNT DUP（O）      ；输入缓冲区BUF2
 DATA  ENDS
 STACK SEGMENT  USE16  STACK
       DB   200 DUP(0)
 STACK ENDS
 CODE  SEGMENT  USE16
       ASSSUME  DS:DATA,ES:DATA,CS:CODE,SS:SATCK    
       ;看到DS与ES是重合的
       ;上面都是些套路写法关键是下面
START:MOV  AX，DATA
      MOV  DS，AX      
      MOV  ES，AX    ；当前数据段和当前附加数据段重合            
      LEA  SI，STR1  ；源串首址送SI
      LEA  DI, STR2  ；目的串首址送DI
      MOV  CX，COUNT ；串长度送CX
      CLD            ；将DF清0，其实DF默认0，一般不用清除。
      REP MOVSB       ；重复传送CX次，每次CX--,直至CX=0
      MOV  AH，4CH       
      INT  21H
 CODE ENDS
      END  START
```



```asm
;“ REP MOVSB”语句代替了以下程序段:
; REP 代替了 loop p
; MOVSB 代替了赋值和指针移动
P:  MOV  AL,   [SI]                 
    MOV  [DI],   AL         
    INC  SI                     
    INC  DI                  
    LOOP P                   
;由于每个汇编源程序的开始时, DF=0为默认状态,一次不用专门使用CLD指令。  
```

如果想要反向操作呢？就是从后往前赋值BUF1，之前是从前往后复制的BUF1

```asm
;反向操作的源程序:
	STD  ;关键是这里DF设1，从后往前
    LEA SI,BUF1+COUNT-1;把尾部的指针给SI
	LEA DI,BUF2+COUNT-1
	MOV CX,COUNT
    REP MOVSB
    
;"REP MOVSB"语句代替了以下程序段
	P: MOV AL, [SI]                 
	   MOV [DI],AL         
   	   DEC  SI
	   DEC  DI                 
	   LOOP P   
;由于DF=0为默认状态,故须使用STD
;指令设置DF=1,才能反向操作. 
```

注意两点：

1. 目的串一定要放在附加数据段中，所以不要忘记定义附加数据段，一般**是使当前数据段与附加数据段重合**
   
   ```
   即  ASSUME   DS:DATA , ES:DATA
   	 MOV AX,DATA
        MOV DS,AX
   	 MOV ES,AX   这几条语句处理。
   ```
   
   
   
2. 一定要注意DF，程序开始时系统自动设DF=0，所以一般不需要用CLD
   
   ```
   CLD 可时DF=0
   STD 可使DF=1
   ```
   
   

## （2）串比较指令      CMPS

格式：CMPS  OPD，OPS

> CMPSW 字串比较，CMPSB 字节串比较，CMPSD 双字串比较

功能：

1. ( DS：[SI] / [ESI] ) —( ES：[DI] / [EDI] )，即将SI/ESI所指的源串中的一个字节(或字、双字)中的数与DI、EDI所指的目的串中的一个字节 (或字、双字)中的数据相减，并根据相减的结果**<u>设置标志位</u>，结果并不保存**。
2. 同样DF决定方向

说明:
该指令可带的重复前缀为:

1. REPE/REPZ       当(CX/ECX)≠0时,如两串对应字符**相等继续比较**（即ZF=1），不相等跳出循环;
2. REPNE/REPNZ  当(CX/ECX)≠0时,如两串对应字符**不相等继续比较**（即ZF=0），相等跳出循环;

**注意这里的比较与CMP有个重要区别**

> CMP是OPD-OPS
> CMPS是OPS-OPD

例2:
  从键盘输入一字符串至STR1为首址的字节缓冲区中，试比较该串与字节字符串STR2是否相等，相等则0→BX;不等-1→BX。

```asm
.386  
DATA     SEGMENT  USE16 
STR1     DB  80   ;缓存区大小，第一个字节
         DB  0    ;实际长度为0 ,第二个字节
         DB  80 DUP(0)  ;初始化全是0
STR2     DB  ′WAN1．ASM′   
COUNT    EQU ＄-STR2   
DATA     ENDS   
STACK    SEGMENT  USE16  STACK   
         DB   200   DUP(0)   
STACK    ENDS   
CODE     SEGMENT  USE16 
         ASSUME   DS:DATA，ES:DATA，SS:STACK，CS:CODE ;DS与ES都要一样
START:  MOV   AX，DATA   
	 	MOV   DS，AX   
		MOV   ES，AX   
	 	LEA   DX，STR1   
        MOV   AH，10                  
		INT   21H      ;上面三句是输入一串字符至STR1缓冲区           
        MOV   AL，STR1＋1   ;STR1+1是STR1的第二个字节，放的实际长度
		CMP   AL，COUNT         
		JNE   EXIT     ;上面三句比较两串长度是否相等，不等转EXIT
        LEA   SI，STR1＋2  ;STR1+2才是输入的字符串的开始
        LEA   DI，STR2   
        MOV   CX，COUNT   
        REPZ  CMPSB    ;逐一比较两串的对应字符是否相等 ,ZF=0,代表不等，跳出循环。
        JNE   EXIT      ;ZF=0不等，转EXIT   
        MOV   BX，0     ;CX循环完，相等ZF=1，0→BX   
        JMP   RETU   
EXIT:   MOV   BX，-1   
RETU:   MOV   AH，4CH   
        INT   21H   ;结束调用
CODE    ENDS   
END     START 
```



## （3）串搜索指令      SCAS

格式：SCAS  OPD

> 同理SCASB是字节串搜索， SCASW 字串搜索 ，SCASD  双字串搜索 

功能: 

1. 字节操作：(AL)   - (ES：[DI]/[EDI]）
   字操作：    (AX)  - (ES：[DI]/[EDI])
   双字操作：(EAX)- (ES：[DI]/[EDI]) 
> 所以是把要搜索的内容放在AL/AX/EAX中，待搜索串放在 (ES：[DI]/[EDI]) 中

2. 修改串指针使之指向下一元素，修改方式同样看DF

   - 当DF＝0时，(DI)/(EDI)增量1(字节操作)或 2(字操作)或4(双字操作)。

   - 当DF＝1时，(DI)/(EDI)减量1(字节操作)或2(字操作)或4(双字操作)。 

     > 于前面两个的不同之处在于，不用将(SI/ESI)一起操作了

3. 修改循环变量(CX)/(ECX) -1→ (CX)/(ECX)

4. 结果也是在标志位里，ZF

说明:

1. **待搜索串一定要是目的串**,放在当前附加数据段中,指针为DI/EDI;
2. 该指令可带的重复指令为:
   - REPZ/REPE   若(CX/ECX)≠0且**相等时**接着搜索.
   - REPNZ/REPNE 若(CX/ECX)≠0且**不相等时**接着搜索.

例3     从键盘输入一串字符至ASS区,试用串搜索指令在该串中搜索子串’AM’出现的次数→BX
思路：先搜索A，搜到A之后看它下一个是不是M，若是，INC BX，若不是，再找下一个A。

```asm
.386
DATA    SEGMENT  USE16 
ASS	    DB	  80 
        DB    0
        DB    80 DUP(0) ;输入的缓冲区
DATA    ENDS   
STACK   SEGMENT  USE16  STACK   
        DB 200 DUP(0)   
STACK   ENDS   
CODE    SEGMENT  USE16 
        ASSUME    DS：DATA，ES：DATA，SS：STACK, CS：CODE 
START:  MOV  AX，DATA   
        MOV  DS，AX   
        MOV  ES，AX ;数据段与附加数据段重合
	    LEA  DX，ASS   
    	MOV  AH，10
	    INT  21H ;10号调用，输入目的串
		LEA  DI,ASS+2 ;放入串首址
		MOV  CL,ASS+1 ;放入串长
		MOVZX CX,CL  ;无符号扩展,前面用0扩展
		;不能 MOV CX, ASS+1 它会取一个字出来。实际上我们只要一个字节的东西。
    	MOV  AL，′A′
	    MOV  BX，0  ;计数器清0，不需要CLD，DF=0默认
	P:  REPNE SCASB   ;查找字符 'A'（AL的内容）              
        JE   A        ;找到了跳到A         
        JMP  OUT1     ;没找到，说明查完了，可以退出了。               
	A:  CMP  CX,0	  ;看有没有扫描完整个str
        JE  OUT1	  ;全部查完转结束
	    CMP BYTE PTR [DI], ‘M’ ;判断”A”后的字符为”M”否
	    ;因为经过SCAS会修改指针指向串的下一个元素。
	    JNE B        ;为何不直接转P？
        INC  BX      ;找到了AX，所以BX++
	B:  JMP  P                       
   OUT1: MOV  AH，4CH   
         INT  21H   
   CODE  ENDS   
         END  START 
```



>    CX是输入串的长度，重复前缀每次循环都会让它自减一。

## （4）取字节/字/双字串指令   LODS

格式： LODS  OPS  

功能：将SI/ESI所指的源串中的一个字节(或字、双字)存储单元中的数	据取出送入AL(或AX、EAX)中。

由于该指令的目的地址为一固定的寄存器，如果带上重复前缀，源串的内容将连续地送入AL(或AX、EAX)中，操作结束后，AL(或AX、EAX)中只保存了串中最后一个元素的值，这是没有多大意义的，因此，该指令一般不带重复前缀。  

## （5）存储字节/字/双字串指令    STOS

格式：  STOS  OPD

功能: 
       字节操作：(AL)→ ES：[DI]/[EDI] 
	   字操作：  (AX)→ ES：[DI]/[EDI] 
	   双字操作：(EAX)→ES：[DI]/[EDI] 

1. 即将AL(或AX、EAX)中的数据送入DI/EDI所指的目的串中的字节(或字、双字)存储单元中。修改指针DI/EDI，使之指向串中的下一个元素。 
2. 该指令执行后，并不影响标志位，因而它一般只带REP重复前缀，用来将一片连续的存储字节(或字)单元置相同的值。 

##   （6）总结

⑴ 源串指针:	DS: SI/ESI 即源串在当前数据段
⑵ 目标串的指针:	ES: DI/EDI 即目的串在当前附加数据段
⑶ 重复计数器:	CX/ECX
⑷ 中间寄存器:	AL/AX/EAX
⑸ 传送/比较方向:	DF=0, SI/ESI, DI/EDI自动增量(加1/加2/加4).
			                	DF=1, SI/ESI, DI/EDI自动减量(减1/减2/减4).
⑹ 指令格式: 带操作数:   ×××S
			         不带操作数: ×××SD (双字操作) 
					                     ×××SW (字操作)
					                     ×××SB (字节操作)	

# 5.2 宏功能程序设计

## ⑴ 宏定义 

对经常使用的具有独立功能的程序段，会设计成子程序，供反复使用，**但使用子程序需要额外付出时间和空间上的开销**。如果只是一组比较简单的语句序列，子程序调用的开销可能大于子程序，这显然不合算。
**宏指令和宏库能简化源程序的结构，具有诸多优点。**

​		**能使用形参，实参来传递参数，不用考虑用寄存器来传递**

定义格式: 

```asm
宏指令名 MACRO  形式参数  [，形式参数]
        宏体
	    ENDM 
比如常用的9号调用可以写成下面这样
writing MACRO A
	    LEA DX,A
	    MOV AH,9
	    INT 21
	    ENDM
;当然这里没考虑现场保护啥的。
```

说明:

1. 宏名字可以与其他变量,标号,保留字同名,汇编程序在处理时宏名字优先级最高.利用这一特点,程序员**可以设计新的指令系统.**
2. 形参可有可无，个数不限，但总字符长度不超过132个，每个参数之间用逗号隔开;
3. **ENDM**和**MACRO**必须成对出现;
4. 宏指令必须==**先定义后调用**==，因为它是在汇编期间处理的.

## ⑵ 宏调用与宏扩展

调用格式: ` 宏指令名 [实参 [，实参]……] `

```asm
;举例：
WRITE  BUF1      ;宏调用  WRITE是宏名
         ┇           
WRITE  IN_BUF    ;宏调用
```

汇编程序的处理方式:

1. 第一次扫描时,先扫描宏定义,将宏名字、形参、宏体均**填入宏定义表中**，再遇到宏调用时则嵌入宏体，用实参按位置顺序替换形参，这一过程称为**宏扩展**。
2.  第二次扫描时,再将其转换成目标代码.

说明:

1. 宏指令名要与原宏定义的名字一致;
2. 实参与形参应按位置关系一一对应:
   - 实参个数多形参，**多余实参被忽略**
   - 实参个数小于形参，缺少的实参被处理成空白(没有字符)。

## ⑶ 宏指令中的参数

#### 一、带几个符的参数

有时实参是一串**带间隔符的字符串**，为了不致混淆，应该尖括号将它们括起来，说明为一个参数.

DEF_STACK <200  DUP(1)>
其中实参为一个重复子句，它中间带有空格，因此要用尖括号括起来 

#### 二、数字参数

**用实参符号所代表的值，而不是实参本身来替换形参**

用`%`来将其后面的表达式转换成它代表的数值，然后再代入到宏扩展中。

这部分见书P165

<img src="5_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E6%9C%AF.assets/IMG_20200509_165339.jpg" alt="IMG_20200509_165339" style="zoom:50%;" />

#### 三、宏参数的连接

有些**形参要夹在字符串里面**，为了标识这种形参，用`&`标识出来

形参前加`&`，如果形参后面还有字符串，则在形参后面也加个`&`

见书P165

![IMG_20200509_165550](5_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E6%9C%AF.assets/IMG_20200509_165550.jpg)

#### 四、宏体中的变量与标号

宏定义的宏体中，如果有标号，那么在**调用多次**的情况下，宏扩展之后，发现有多个重复的标号。引起了重复定义的错误。为了避免这种情况，有两种解决办法。（其实调用多次一般都用子程序了）

1. 将**标号定义成形参**,每次调用均用实参代替.但会造成参数过多,给编程带来麻烦; 		

2. 使用**伪指令LOCAL**,让机器自动生成不同标号.

   格式: LOCAL   形式参数[,形式参数……]
   功能: 宏拓展时,汇编程序自动为其后形参生成特殊顺序号,	范围为??OOOO - ??FFFFH,并用之取代形参,避免重复定义

   > 注意LOCAL语句只能做宏体中的第一个语句
   
   ```asm
   ABS MACRO VAR;形参
   	LOCAL P;形参，本地标号。
   	CMP VAR ,0
   	...
   	...
   P:	...
   	ENDM
   ```
   
   

## ⑷ 宏库的使用

- 对于**经常使用的宏定义**，用户可将它们集中在一起，建成宏库供自己或别人随时调用。
- 由于宏库为文本文件，可用一般编辑程序建立或修改，文件名也可由用户任意指定。 
- 当程序中需要调用时，应首先将宏库加入自己的源文件中，然后按宏库中各宏定义的规定调用即可。

例如：我们利用编辑程序，建立了一个宏库`MACRO.LIB`

将宏库加入源文件一起进行汇编可用伪指令INCLUDE实现。 

- 语句格式：INCLUDE  文本文件名 
- 功能：将指定的文本文件从本行起加入汇编，直到该文本文件的最后一行汇编完后，再继续汇编INCLUDE后面的语句   

## ⑸ 宏指令与子程序的比较:smiling_imp:

不同点:

1. 处理时间不同
   宏指令在**汇编期间**，由宏汇编程序处理——第一次扫描的时候就处理进去了。
   子程序调用在目标程序**运行期间**，由CPU直接执行。
2. 处理方式不同;
   宏指令必须**先定义后调用**，宏调用用**宏体**置换宏指令名，**实参**替换形参
   子程序调用则无需先定义后调用。
3. 目标程序的长度不同;
   使用宏指令**不会缩短目标程序**，因为每调用一次就宏扩展一次，不会缩短目标程序
   宏程序每次调用都是在同一个地址，因此多次调用实际上是缩短了目标程序的。
4. 执行速度不同;
   子程序要用堆栈<u>保护现场和恢复现场</u>，**速度慢**。
   宏指令不存在这些问题，因此**执行速度快**
5. 参数传递方式不同;
   宏调用有**实参形参代换**，比较**灵活方便，简单，参数形式也不受限制**
   子程序有限制，也比较**麻烦，容易出错**。

## (6)重复汇编伪指令

也是一些宏，但是宏指令名不是MICOR，而是被指定的。注意这个不用先定义后调用。

### 1.REPT

```ASM
PEPT 表达式;即重复次数
	 重复块
	 ENDM
```

### 2.IRP

```ASM
IRP 形参，<实参1，实参2，...>;依次代入
	重复块
	ENDM
```

### 3.IRPC

```Asm
IRPC  形参,字符串;每个字符依次代入
	 重复块
	 ENDM
	 ;字符串中的每个字符代入形参。
例如：
IRPC CHAR,DBCA ;DBCA这四个字母依次代入下面的CHAR形参中。
	 POP &CHAR&X
	 ENDM
```

## (7)条件汇编伪指令

条件汇编指：允许宏汇编程序根据条件决定某一段程序是否参加汇编
对不满足条件的部分则不予汇编，即不生成目标代码。

```ASM
IFXX [条件表达式]
	语句块
[ELSE IF 
	语句块]
END IF
```

它这个IF有很多种，IF,IFE,IFB等等，见P170

# 5.3 模块化程序设计

什么是模块？

- 一个以==END语句==为结束的源程序称为一个模块。一个模块是一个独立的汇编源文件，一个模块汇编后生成一个目标文件（*.obj），或称目标模块。
- 模块化程序是由一个以“END 标号”结束的**主模块**，和几个以“END”结束的**子模块**组成。

模块化程序的作用：

- 用于大型程序系统的设计。通过模块的划分，将复杂的问题合理分配到各子模块中去解决，便于多人合作，编程的质量和效率都会提高。
- 此外，通过模块的划分，可以**针对不同模块的特性，采用不同的语言编程**，有利于发挥各计算机语言的特性。

模块化程序设计主要解决的问题：

- 如何正确地划分模块（在5.4.1小结中介绍）
- 如何把模块装配在一起（这里重点讨论这个）

## 5.3.1 段的组合方式

段定义语句：

```asm
段名  SEGMENT  [使用类型] [定位方式]  [组合方式]  [‘类别’]
 …
段名  ENDS
;使用类型如果没有就默认是16位的，即常用的USE16
;定位方式指定各段起始物理地址的确定方式，默认PARA
;组合方式默认none,与其他段连起来就是PUBLIC
;类别同段名不一定同，同类别的放在一起
```

### 1. 定位方式

定位方式是用来指定各段的起始物理地址的确定方式。
告诉连接程序，在将各个段装配在一起时，**前一个段放完后，后面一个段将从一个什么样的起始边界开始存放。**

有四种不同的选择：

- PARA：段从**能被16整除**的地址开始存放。（**缺省方式**）
  即物理地址的最后4位必须是0。
- WORD：段从一个**偶数地址**开始存放。（能被2整除）
- BYTE：对段存放的首地址不作要求。
- PAGE：段从能被**256整除**的地址开始存放
  即物理首址的最低8位必须是0。

> 但由于段寄存器表示的段首地址最低四位只能为0，而选择WORD和BYTE方式时，该段的首偏移地址可以不再从0开始。P178，一般选用PARA最多

已知程序中的DATAl段和DATA2段的定义如下，如果这两个段分别为当前数据段和当前附加数据段．试分析下述连接程序对它们边界的处理方法。

```asm
DATA1    SEGMENT USE16
A        DB  55H  DUP(0FFH) 
DATA1    ENDS    
DATA2    SEGMENT USE16      
	     DB  64H  DUP(0)
DATA2    ENDS
```

由于这两个段均未明确指定定位方式，说明它们的定位方式均为PARA。那么物理地址后4位都得是0，故EA首址必须从0000开始。

![image-20200307214727932](5_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E6%9C%AF.assets/image-20200307214727932.png)

### 2. ‘类别’

‘类别’是用单引号括起来的**字符串**，该字符串可以是任何合法的名称。连接程序在进行连接处理时，**将‘类别’相同的段（它们不一定同名）**，**按出现的先后次序连续存放**（但仍是不同名的段），且每段都有自已的首址。

> 注意，这只是放在了一起，还没连接，要看后面的组合方式

```
例如：
有5个段名不同的段，分属三个不同的‘类别’，连接时。五个段按以下顺序提供给连接程序：
A    SEGMENT    ‘DATA’
B    SEGMENT    ‘CODE’
C    SEGMENT    ‘TO’
D    SEGMENT    ‘DATA’
E    SEGMENT    ‘TO’

连接后，在生成的.EXE文件中，各段的相对位置成为
A    SEGMENT    ‘DATA’
D    SEGMENT    ‘DATA’
B    SEGMENT    ‘CODE’
C    SEGMENT    ‘TO’
E    SEGMENT    ‘TO’
```



### 3. 组合方式

组合方式向连接程序提供了本段同其它段的组合关系，主要有：

1. **NONE**（不选择）：本段与其它段不发生任何逻辑上的联系，自己有自己的段首址。（隐含的）
2.  **PUBLIC**：表示应将本段与其它模块中的==同名、同‘类别’段==按各模块连接的顺序相邻地**连接在一起，组成一个物理段， 大小不超过64K**。
   合并的好处：以数据段为例，当组合成一个段后，在子模块中就不用再对DS送首址，方便而又有效。
3. STACK：仅对堆栈段，功能同PUBLIC。 
4. COMMON：表示本段与同名、同‘类别’的其它段应<u>具有相同段首址</u>，即**相覆盖**。**长度取决于最长的COMMON段。**
5. “AT表达式”：表示该段应放在表达式所指定的绝对地址上。
6.  “MEMORY”：表示该段应放所有段之上（最高地址上）。

> 注意，对16位段程序而言，通过PUBLIC连起来的程序，大小不超过==64K==，这是由2^16得到的

![IMG_20200509_172107](5_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E6%9C%AF.assets/IMG_20200509_172107.jpg)

## 5.3.2 通讯方式

1. 局部符号：
    **仅在定义自己的模块中**被访问的符号为局部符号。

2. 公共符号：
不仅被定义自己的模块访问，**还要供其它模块访问**的符号为公共符号。要用`PUBLIC`伪指令说明。其格式为：
         PUBLIC  符号[，符号，……]
   
   *说明可以被其他模块引用*
   
3. 外部符号：
    只在模块内访问而**不在该模块内定义的符号为外部符号**。要用EXTRN伪指令说明。其格式为： 
    EXTRN  符号：<u>类型</u>[，符号：类型，……]

> 见书P180，这部分也不咋会考吧。
>
> 注意外部符号你要说明类型，因为在外部定义的，不知道类型的。

## 5.3.3 连接程序（LINK）的功能

​	将制定的若干个目标模块（.OBJ）和子程序库（.LIB）中的子程序模块连接在一起，生成可执行的文件（.EXE）并产生一个地址分配文件（.MAP）

> 我注意到，用link去连接默认不会产生.MAP，而是要自己选产不产生。
> 用TLINK去连接默认会产生这个

## 5.3.4 地址分配文件（.MAP）举例

地址分配文件（.MAP）用以描述执行文件中<u>各段的浮动起始地址、结束地址、所占用空间大小、段名及‘类别，还可列出各模块中所定义的公共符号及其偏移地址</u>，它主要用于程序调试及资料归档。

> 具体例子见书P184，这个也不会考

## 5.4 源程序综合举例

我估计是不用怎么看的，把概论看一看就行，别太费心思，有点麻烦。

他们本科的也没有涉及到有的部分，应该不会这么深入，写几个实现功能的小程序还差不多，不可能要你直接模块化设计的。

## 5.4.1 模块程序设计中的注意事项

> 不用怎么看。

### 1. 模块的划分的规则

1. 如果一个程序段被很多模块所公用，则它应是一个独立的模块。 
2. 如果若干个程序段处理的数据是公用的，则这些程序段应放在一个模块中。 
3. 若两个程序段的利用率差别很大，则应分属于两个模块。 
4. 一个模块既不能过大，也不能过小。过大则模块的通用性较差，过小则会造成时间和空间上的浪费。 
5.  力求使模块具有通用性，通用性越强的模块利用率越高。 
6. 各模块间应在功能上、逻辑上相互独立，尽量截然分开，特别应避免用转移语句在模块间转来转去。 
7.  各模块间的**接口应该简单**，要**尽量减少公共符号的个数**，尽量不共用数据存储单元，在结构或编排上有联系的数据应放在一个模块中，以免互相影响，造成查错困难。 
8. 每个模块的结构应尽量设计成单入口、单出口的形式。这样的程序便于调试、阅读和理解且可靠性高。 

### 2. 程序文件的命名

(1) 标识出程序设计者。即在文件名中用一符号作程序员代号。这样，当制作的模块很多时，通过文件名就应能分辨出各个模块的设计者；每个程序员又可在其代码之后加一数字，标识本人编写的不同模块。这样，遇有问题就可快速找到出处，进行追踪。
(2) 简单标识模块功能。在文件名中标识出模块功能可方便调用与连接。
(3) 标识出模块之间的连接关系：即指一个模块在待连接的一串模块中的位置，可在文件名最后以数字表示顺序。

### 3. 标号的定义

标号名不仅要统一，最好包含它的功能和所有必备的信息。标号所代表的信息有：
(1) 模块出处：即为程序员的代号和附加编号。 
(2) 功能名称：明确的功能定义可以提高模块的再利用价值。功能名称部分长度以三个字母为宜，太长则输入费时。
如：
DSP 表示屏幕显示功能
PRN 表示打印功能
KIN 表示键盘输入功能
(3) 分支代号：程序中的分支代号最理想的是由小而大依序安排，为适应编写程序中的变化，可预留空号以便扩充。

### 4. 变量和缓冲区的定义

例如：这是一些通用命名规则。

- 第一个字母用“Ｂ”为缓冲器名开头；用“V”为变量名开头；用“S”为字符串名开头。
- 第二个字母可代表定义的类型:
  - Q=QWORD　　 如:BQxxxx 缓冲器为4字类型。
  - D=DWORD　　 如:BDxxxx 缓冲器为双字类型。
  - W=WORD　　   如:VWxxxx 变量为字类型。
  - B=BYTE　　　  如:VBxxxx 变量为字节类型。
  - S=STRING　　  如:Sxxxxx 为字符串（字节类型）。
  - F=FLAG　　　  如:VBFxxx 该变量为字节型类，用作标志。

### 5. 模块注释

为方便子模块的调用，在子模块的前面必须有详细的说明。说明的内容包括：子模块功能、调用此子模块的入口参数和出口参数、子模块中所使用的主要变量等。 

## 5.4.2 模块程序设计举例

这部分见书P187



# 总结

## 1. 串操作指令

- 串传送指令：
  MOVS  OPD，OPS/MOVSB/MOVSW
- 串比较指令：
  CMPS  OPD，OPS/CMPSB/CMSW
- 串查找指令：
  SCAS  OPD/SCASB/SCASW  
- 从源串中取数指令：
  LODS  OPS/LODSB/LODSW
- 从目的串中送数指令
  STOS  OPD/STOSB/STOSW

## 2. 宏功能程序设计

- 宏指令的定义与调用方式；带间隔符实参的表示方法；
- 宏体中变量和标号；为避免重复定义要用LOCAL；
- 宏定义与子程序的区别。
- 宏库。

## 3. 模块化程序设计

- 定位、组合方式；
- 局部符号、公共符号、外部符号；
- **一般程序改写成子程序、子程序改写成独立子模块的方法**；（这书上有提么？）
- 模块化程序设计的方法

## 作业

课后题做一下，1,2,3,6,9就行

本章重点在宏和串

---

[^1]:P151
[^2]:另外的REPE之类的在这个指令里没必要带，也没用。










